# **Tower Defense Game With Adaptive AI and Random Map Generation**
- ![#f03c15](https://placehold.co/15x15/f03c15/f03c15.png)'WEBGL READY: https://www.defendtillsunshine.com/projects-2'


![TowerDefenseWithRandomTileGeneration - SampleScene - Windows, Mac, Linux - Unity 2021 3 10f1 Personal _DX11_ 2024-02-06 06-26-01](https://github.com/Erces/TowerDefenseWithRandomTileGeneration/assets/51009171/2f8539a0-3487-46fc-a732-39a4517edd7c)

# ARTICLE
## ADAPTİF RAKİP VE OTOMATİK ÜRETİLEN SEVİYELER İLE OYUN

## GELİŞTİRMESİ

## ÖZET

Bu çalışmanın amacı, kullanıcının hamlelerine göre strateji değiştiren bilgisayarın
yönettiği rakibin ve seviyelerin otomatik tasarlandığı bir oyun yazılımı oluşturmaktır.

Öncelikle, daha önce geliştirilen örnekler araştırılmış ve bu örneklerden yapılan
çıkarımlara göre planlama yapılmıştır. Daha sonra hamlelerine bilgisayar tarafından
karar verilen rakibin adaptif hale getirilmesi için kullanılacak yöntemler, oyun
motoru seçimi, otomatik ve prosedürel olarak oluşturulan seviyeler nasıl
geliştirileceği gibi konuların karar verilmiştir.

Proje kapsamında oyun motoru olarak c# programlama dilini kullanan Unity Engine
kullanılmıştır. Oyun ilk aşamalarda klasik bir kule savunma oyunu şeklinde
geliştirilerek temeli atılmıştır. Oyun için bir çok farklı özelliğe sahip düşman birim,
dost savunma birimi ve seviye tasarımı için kullanılan birimler geliştirilmiştir.
Bunların stratejik olarak birbirleri ile uyumlu şekilde çalışması sağlanmıştır. Bunun
yanında bu birimleri daha iyi temsil edebilmesi için 3 boyutlu grafikler
oluşturulmuştur.

Daha sonra yapılan araştırmalar doğrultusunda adaptif rakip ve rakip hareketleri
geliştirilmiş, test edilmiş ve uygulanmıştır. Otomatik ve prosedürel olarak oluşturulan
seviyeler için birden çok sayıda farklı algoritmalar geliştirilmiş ve test edilmiştir. En
uygun olduğu düşünülen otomatik ve prosedürel seviye tasarlama algoritması projeye
uygulanmıştır.

Sonuç olarak geliştirilen kullanıcının konuşma girdisine bağlı ses komutları ile
kullanıcının oyun ile etkileşime geçilebildiği ve yol bulma algoritmalarının
kullanıldığı bir oyun geliştirilmiştir.

**Anahtar kelimeler: Adaptif rakip, düşman birimi, kule savunması, otomatik
oluşturulan seviye.**

```
VI
```

## GAME DEVELOPMENT WITH ADAPTIVE COMPETITORS AND

## AUTOGENERATED LEVELS

## ABTRACT

The aim of this study is to create a game software in which the opponent and levels
are automatically designed by the computer, which changes the strategy according to
the user's moves.

First of all, previously developed examples were researched and planning was made
according to the inferences made from these examples. Then, the methods to be used
to adapt the opponent, whose moves are decided by the computer, the choice of game
engine, how to develop automatically and procedurally generated levels were
decided.

Unity Engine, which uses the c# programming language, was used as the game
engine within the scope of the project. The foundation was laid by developing the
game as a classic tower defense game in the early stages. For the game, many
different enemy units, friendly defense units and units used for level design have
been developed. It has been ensured that they work in harmony with each other
strategically. In addition, 3D graphics have been created to better represent these
units.

Adaptive competitor and competitor movements have been developed, tested and
applied in line with subsequent research. Multiple different algorithms have been
developed and tested for automatic and procedurally generated levels. The automatic
and procedural level design algorithm, which is considered to be the most
appropriate, has been applied to the project.

As a result, a game has been developed in which the user can interact with the game
with voice commands depending on the user's speech input and path finding
algorithms are used.

**Keywords: Adaptive opponent, auto-generated level, enemy units, tower
defense.**

```
VII
```

## GİRİŞ

Dijital oyunlar için kullanıcıların tek başlarına vakit geçirirken rekabet duygusunu

yaşaması için geçmişten günümüze birçok farklı tarzda ‘rakip yapay zeka’

tasarlanmıştır. Bu bazen ‘pong’ oyunundaki gibi basit ya da bazı yeni dijital

oyunlardaki gibi karmaşık yapay zekalar olabiliyor. Ancak bu yapay zekalar aslında

sadece belli kuralları gerçekleştiren ve aslında yapay zeka olmaktan oldukça uzak

olan belirli kurallardan ibarettir. Bu tür dijital oyunlarda oyun boyunca bilgisayar

sadece kod aracılığı ile belirlenmiş bu kuralları belli şartlar gerçekleştiğinde

uygulayarak bir yapay zeka varmış algısı oluşturmuştur. Bu proje ile hedeflenen ise

aynı şeyleri tekrarlayan bir bilgisayar rakiptense kullanıcının hareketlerine göre

stratejisini değiştirip kullanıcıya daha değişken ve farklı bir oyun deneyimi sunmak

olmuştur. Bu şekilde kullanıcıya da farklı stratejiler kullanması için kapı açılmıştır.

Dijital oyunlar için seviye tasarımı, geliştirme aşamalarının ana odaklarından biridir.

Hatta bazı oyunlar için en önemli kısım ve asıl içeriği sağlayan kısım olmuştur. Oyun

seviyeleri kullanıcılar tarafından üstesinden gelmesi beklenen birçok rakip ve engel

ile donatılmıştır. Bu seviye geliştirmelerinin nasıl olacağı bu alanda özel olarak

çalışmış insanlar tarafından uzun süreler sonucu belirlenir. Bunun nedeni bu

seviyelerin hepsinin teker teker en ince ayrıntısına kadar düşünülmesi olmuştur. Bu

tasarımlar kağıt üzerinde yapıldıktan sonra bu seviyelerin yazılım kısmına dökülmesi

gerekmektedir. Bu durum da işi ekstra olarak uzatmaktadır. Bu çalışmada ise

hedeflenen bu uzun geliştirme sürelerini kısaltmak ve içerik konusunda oyunu tam

tersi orantı ile kolayca arttırmak olmuştur. Bu sayede gereken iş yükünü ve

geliştirme zamanını azaltıp kullanıcıya oynaması için birbirinden farklı birçok

seviye sunulması amaçlanmıştır.


## 1. LİTERATÜR TARAMASI

**1.1 Giriş**

Adaptif rakip ve otomatik geliştirilern seviye ile oyun geliştirme konusu farklı
temalar üzerinden araştırılmıştır. Bu temalar “Adaptif Oyun Yapay Zekası” ve
“Oyunlarda Prosedürel ve Otomatik Seviye Tasarımı” şeklinde ikiye ayrılmıştır.
Adaptif oyun yapay zekasına sahip oyunların tasarımı hakkında ve oyunlarda klasik
yapay zeka hakkında yapılmış geçmiş araştırmalara göz atılmıştır. Bunun yanında
oyunlarda prosedürel ve otomatik seviye tasarımı konusunda farklı tasarım
çeşitlerine değinen araştırmalara yer verilmiştir.

**1.2 Adaptif Oyun Yapay Zekası**

“Adaptive game AI with dynamic scripting” [1] isimli çalışma 2006 ’da yapılan
Oyunda Bilgisayar-İnsan Etkileşimi Yıllık Sempozyumu bildirilerinden biridir.
Çalışmanın yazarları Fraser Allison, Marcus Carter, Martin Gibbs ve Wally Smith
olan bu çalışma ses interaksiyonuna sahip oyunların geliştirmesinde kullanılacak
dizayn modelleri oluşturma amacıyla yapılmıştır.

Çalışmanın giriş kısmında klasik oyun yapay zekalarının tahmin edilebilir, karşısında
belli durumlara karşı adapte olunabilir olduğundan bahsedilmiştir. Klasik yapay
zekanın kullanıcılar tarafından kolayca zayıflıklarından faydalanabileceğinden,
klasik yapay zeka sürekli aynı şeyi tekrarladığından kullanıcının kolayca adapte olup
rakip yapay zekayı zorlanmadan yenebileceği konu edilmiştir. Adaptif oyun yapay
zekasının ise değişen durumlara göre kendini başarılı bir şekilde değiştirip duruma
adapte olup kullanıcıya her seferinde farklı bir zorluk çıkararak oynadığı oyundan
keyif almasını sağladığı söylenmiştir. Oyun geliştiricilerin normalde oyunlarını
harika grafiklerle pazarlamaya çalıştığını ve günümüzde ise bunun değişip artık daha
iyi bir oynanış tecrübesine kaydığına, bunun da ancak iyi bir oyun yapay zekası ile
olabileceğine değinilmiştir.

Çalışmada adaptif oyun yapay zekasının nasıl olması gerektiği birçok konu başlığı
altında değerlendirilmiştir. Bu konu başlıkları hız, efektiflik, sağlamlık, yeterlilik,
netlik, varyasyon sahibi olması, tutarlılık, ölçeklendirilebilirlik olarak 8 konu
başlığına ayrılmıştır. Bu 8 konu başlığı da aslında ikisinde de dört adet kural olmak
üzere hesaplamalı ve fonksiyonel konu başlıkları olarak iki kısma ayrılmıştır.
Hesaplamalı özellikleri kendisinde karşılamayan oyun yapay zekasına gereksiz ve işe
yaramaz denmiştir. Fonksiyonel özellikleri kendisinde barındırmayan başlıklar ise
opsiyoneldir. Yani fonksiyonel başlıklara sahip olmasa bile oyun yapay zekası yine
de başarılı denilebilir.


Hız: Uyarlanabilir oyun yapay zekası, öğrenme gerçekleştiği için hesaplama
açısından hızlı olmalıdır. Hesaplamalı özellik olarak geçmiştir.

Etkililik: Uyarlanabilir oyun yapay zekası, tüm öğrenme süreci boyunca etkili
olmalıdır çünkü manuel olarak tasarlanmış oyun yapay zekasından daha kötü hale
gelmesinden kaçınılması gerekmektedir. Etkili olduğunda, uyarlanabilir oyun yapay
zekası, makul derecede başarılı davranışlar üretir. Oyun yayıncılarının temel korkusu
olan kullanıcıların rakiplerin davranışı öğrenmesi olayını çözer. Hesaplamalı özellik
olarak geçmiştir.

Sağlamlık: Uyarlanabilir oyun yapay zekası, doğasında bulunan rastgeleliğe göre
çoğu oyunda sağlam olmalıdır. Hesaplamalı özellik olarak geçmiştir.

Verimlilik: Uyarlanabilir oyun yapay zekası, öğrenme sayısına göre oldukça verimli
olmalıdır çünkü tek bir oyunda bir oyuncu benzer durumlarla sınırlı sayıda
karşılaşma durumunda kalır. Hesaplamalı özellik olarak geçmiştir.

Netlik: Uyarlanabilir oyun yapay zekası kolayca yorumlanabilir sonuçlar üretmelidir
çünkü oyun geliştiricileri sonuçlarının anlaşılması zor olan öğrenme tekniklerine
güvenmezler. Fonksiyonel özellik olarak geçmiştir.

Çeşitlilik: Uyarlanabilir oyun yapay zekası, oyuncuya daha fazla eğlence faktörü
sağlaması için çeşitli farklı davranışlar üretmelidir. Fonksiyonel özellik olarak
geçmiştir.

Tutarlılık: Uyarlanabilir oyun için gereken ortalama öğrenme fırsatı sayısı başarılı
sonuçlar üretmek için yapay zekanın yüksek tutarlılığı yani düşük varyansı,
başarılarının hem insan davranışlarından bağımsız olmasını sağlamak
oyuncu ve öğrenme sürecindeki rastgele dalgalanmalardan bağımsız olması
sağlanmalıdır. Fonksiyonel özellik olarak geçmiştir.

Ölçeklenebilirlik: Uyarlanabilir oyun yapay zekası, sonuçlarının zorluk seviyesini
insan oyuncunun beceri seviyesine göre değişebilir ve ölçeklenebilir olmalıdır.
Fonksiyonel özellik olarak geçmiştir.

Daha sonra çalışmada dinamik komut dosyası oluşturmadan bahsedilmiştir. Dinamik
komut dosyası oluşturma, birkaç kural tabanını korur. Kullanıcılar tarafından duruma
göre her yeni örneği oluşturulduğunda kural tabanları aracının davranışını kontrol
eden yeni bir komut dosyası oluşturmak için kullanılır. Kurallar belirli bir aracıyı
kontrol eden bir komut dosyası içerir, ilgili kural tabanından çıkarılır. Bir komut
dosyası için bir kuralın seçilme olasılığı her kurala eklenen bir ağırlık değeri
tarafından etkilenip değişikliğe uğrar. Dinamik komut oluşturmanın amacı,
kural tabanlarındaki ağırlıkların adapte edilmesi, değişen ortamlarda bile hızla
artmasıdır. Komutlarda karşılık gelen kuralların ağırlık değişiklikleri ağırlık
güncellemesi ile belirlenir.


Şekil 1.1 Adaptif Yapay zekanın dinamik komutlarla çalışma örneği

Bu çalışmada bahsedilen başka bir konu ise bu bu tür yapay zeka kullanıldığında
zorluk dengesinin nasıl olacağı ile ilgili olmuştur. Birçok araştırmacının ve oyun
yapımcısının düşüncesine göre oyun zor olduğunda oyuncu gerçekten eğlenebilir
hale geldiği söylenmiş. Bu oyunlar konusunda yetenekli ve tecrübeli oyuncular için
doğru olsa da amatör kullanıcılar için bu hafif bir zorluğun yeterli olabildiği şeklinde
açıklanmıştır. Dinamik komut ile yani adaptif bir yapay zeka ile bunun nasıl
işeleyebileceği anlatılmıştır.

İncelenen 2. çalışma ‘Adaptive AI for Fighting Games’ [2] olmuştur. Oyunlardaki
yapay zekanın belli bir sınırın ötesine normalde geçemediğini, sürekli belli kurallar
arasında gidip geldiğinden bahsedilmiştir. Oyun yapay zekasında bulunan bir açığın
sürekli kullanılıp kolaya kaçıldığında oyunu kullanıcı için sıkıcı hale getirdiğini
belirtmiş. Klasik oyunlardaki yapay zeka rakibin statik ve değişemeyen bir yapısı
olduğundan strateji değiştirip oyuna denge katmasının imkansız olduğu belirtilmiştir.

Bu çalışmada kullanılmak üzere geliştirilen dövüş oyununda başlangıçtaki
implementasyonlarda taş-kağıt-makas mantığı kullanılmış ancak istenen geri dönüş
alınamamıştır. Bunun dışında kullanılan algoritmalar Naive Bayes, Softmax
Regresyonu, Markov karar verme, Ngram şeklinde farklı çeşitlerde olmuştur. Hepsi
test edildikten sonra Naive Bayes’in en iyi performans veren algoritma olduğu
görülmüştür. Softmax algoritması ise aşırı yavaş olduğundan en başta reddedilen
olmuştur. Daha sonra ortalam kullanıcı üzerinde test yapıldıktan sonra yapay zekanın
aşırı başarılı olduğu ve bütün rakiplerini yendiği görülmüştür. Buna göre ayar
yapılarak düzenlenmiştir.

“An adaptive AI for real-time strategy games” [3] adlı çalışma incelenmiştir. Bu
çalışma adından da anlaşılacağı üzere gerçek zamanlı strateji oyunlarında adaptif
yapay zekanın implementasyonu ile ilgili bir çalışmadır.
Bu çalışmada öncelikle RTS üzere gerçek zamanlı strateji oyunlarında rakip yapay
zekanın nasıl hareket ettiğini anlatılmıştır. Yapay zekanın ana amacının kullanıcıyı
ezici şekilde yenmesi değil, kullanıcıya belli seviyede zorluk hissi ve başarılabilirlik
hissi vermesi gerektiği değinilmiştir.


Bunu yaparken de yeni veya tecrübeli oyuncu farketmeksizin yapabilmesi
gerekmekte olduğu bu ilüzyonun aslında genel olarak oyunlarda yapılan genel bir iş
olduğundan bahsedilmiştir. Adaptif algoritmaların çevrimiçi ve çevrimdışı olarak
yapılabildiğine değinilmiştir. Çevrimdışı adaptif algoritmalar oyun çıkmadan önce
hazırlanıp oyun çıkarken statik bir moda alınıp kullanıcılarla bu şekilde buluştuğunu,
çevrimiçi adaptif algoritmanın ise oyuncular oynadıkça değiştiği söylenmiştir. Bunun
dışında oyundan oyuna öğrenmesinin yanında rakip adaptif yapay zeka devam eden
oyun içinde de öğrenip bunu oyuna dökebilir şeklinde belirtilmiştir. Bunlar oyunun
süresine ve maçların sıklığına bağlı olarak seçilebilir denmiştir.

Strateji oyunundan verilen örnek şu şekildedir: Kullanıcının tanklar üzerinde
avantajlı olan hava birliklerini gönderdiğinde ve bu olayı birçok defa yaşadığında
adaptif yapay zeka bir sonraki oyunda veya bir sonraki aynı oyun kararında tank
göndermeyi bırakıp farklı bir strateji izlemelidir. Bu yeni tarz bir birlik göndermek ya
da tanklar üzerinde avantajlı olan hava birliğini tanklara ulaşmadan elimine edecek
bir birlik olabilir şeklinde örneklendirilmiştir.

‘Effective and Diverse Adaptive Game AI’ [4] adlı bu çalışmada da sıklıkla dinamik
komutlardan bahsedilmiştir. Dinamik komutların başarılı şekilde kullanıldığı birkaç
mrnek oyuna yer verilmiştir. Bunlardan biri ‘Neverwinter Nights’ ve ‘Wargus’ adlı
oyunlardır. Bu oyunlarda makro aksiyonları öğrenmek için evrimsel öğrenme
kullanılmış ve öğrenilen kuralların dinamik komut yazmanın performansını
iyileştirdiğini göstermişlerdir. Bu uygulamalarda, dinamik komut dosyası oluşturma,
bir dizi statik taktiğe hızlı bir şekilde uyarlandı ve etkili karşı taktikleri öğrendi.
Bununla birlikte, oluşturulan komut dosyalarının çeşitli oyun stillerini temsil
etmesini sağlanamamış. Dinamik komut güncellemelerinin artımlı doğası nedeniyle,
arada birkaç yetersiz taktik denemeden başka iki güçlü taktik arasında geçiş yapması
mümkün olmamıştır.

**1.3 Prosedürel ve Otomatik Üretilen Seviyeler**

Prosedürel seviye oluşturması için ilk araştırılan çalışma ‘Procedural Level
Generation Using Ocuupancy-Regulated Extension’ [5] olmuştur. İyi bir prosedürel
seviye oluşturucunun kompleks bir yapının yanında kullanıcıyı görsel açıdan da
tatmin eden estetik bir yapıya da sahip olmasını ve kullanıcıya bu seviyelerin
otomatik olarak oluşturulduğu hissinin olabildiğince az verilmesi gerektiğinden
değinilmiştir. Otomatik prosedürel seviye oluşturması oynanabilir, hatasız ve oyun
içindeki diğer mekanikler ile uyumlu olması gerektiğinden bahsedilmiştir.

Otomatik prosedürel seviye oluşturmasını kullanan Infinite Mario ve Spelunky adlı
iki oyundan örnekler verilmiştir. İki oyununda külçe tabanlı olduğundan bu yüzden
otomatik prosedürel seviye oluşturması için kod geliştirmesinin kolay hale
geldiğinden bahsedilmiştir.
Bu oyunlardan ‘Infinite Mario’ adlı oyunda oluşturucu 5 farklı ana çerçeve arasında
sürekli seçim yapıp bir diğerinin ucuna eklerken bu çerçeveler içerisindeki seviye
yapısını hafif şekilde değiştirerek bunu sağlamıştır. Spelunky’de ise 10x8’lik
odaların içerisindeki her kareyi random şekilde belirleyerek otomatik seviye
geliştirmesi sağlanmıştır.


Bu oyunlarda düşmanlar ya da oyundaki engeller kod içindeki frekans değişkeni ile
sıklığı belirlenebilir ya da belli oyun içi özellikler başka özelliklerle kesinlikle
beraber ortaya çıkması sağlanabilir hale geldiği belirtilmiştir. Aynı şekilde oyunda
bozulma meydana getirebilecek ya da kullanıcının oyunu bitirmesine ve eğlenmesine
engel olabilecek seviye yaratımındaki hatalı kombinasyonlar bu oyunlarda kod
aracılığı ile engellenmiştir.

Şekil 1.2 Infinite Mario Prosedürel Seviye Oluşturma örneği

Oyunlardaki dekoratif amaçlı bileşenler ise herhangi bir otomatik oluşturma
algoritması olmadan manuel olarak eklenmiştir. Çünkü rastgele yapılırsa görsel
açıdan ilgi çekmekten uzak ve itici bir görsellik elde edilebileceği düşünülmüştür.
Buna arkaplan grafikleri şeklinde örnek verilmiştir.

Bu araştırma durak sisteminden, durak noktalarının bir dizi nodeları birleştirerek ve
aralarına yürünebilir bir bağ koyarak oluştuğunu söylemiştir. Bütün noktalar
erişilebilir olmalıdır. Amaç sistemdeki node sayısını az tutmaktır. Durak noktalari
gezinme ağlarında olduğu gibi dinamik dünyalarda faydalı olmamaktadır.

‘Procedural Level Design for Platform Games’ [6] adlı çalışma platform
oyunlarındaki prosedürel seviye oluşturması hakkında yapılmıştır. Bu çalışmada
prosedürel seviye oluşturmasının çok az da olsa birçok farlı türde oyun içinde 1980
yılından beri olduğuna değinmiştir. İlk örneklerden olan ASCII grafik yapılı bir rol
yapma oyunu olan Rogue adlı oyunda sonsuz sayıda zindanın yani oyun seviyesinin
bu prosedürel seviye geliştirme yöntemi ile geliştirildiğinden bahsedilmiştir.


Rogue adlı oyunun haritası için duvar ve boşluk olmak üzere ikiye ayrılan bir yapı
kullanılarak duvarla oyuncuları sınırladığı boşluk kısmında oyuncuların özgürce
dolaşabildiği bir harita oluşturulmuştur. Boşluk noktalarına yerleştirilmiş eşyaları ele
geçirip düşmanları yenmesi şeklinde bir oyun döngüsüne sahip olduğu anlatılmıştır.
Prosedürel seviye oluşturma konusunda kalıplardan bahsedilmiş. Bu kalıplar basit,
kompleks, bileşik ve kompozit kalıplar olarak dört ayrı kategoriye ayrılmıştır.

Temel Kalıplar: Temel bir bileşenden oluşur, ya kendi başına ya da herhangi bir
değişiklik olmadan birkaç kez tekrarlanabilir.

Karmaşık Kalıplar: Karmaşık bir model, aynı kalıbın tekrarıdır ve aynı bileşendir
ancak ince ayarlarla değişmiştir. Bu değişim yönü büyüklüğü gibi özellikler ile
olabilir.

Bileşik Kalıplar: Bileşik bir model farklı iki farklı türden yapılmış kalıplar arasında
yapılan birleşim ile ortaya çıkar. Bunun bir örneği olarak üç üyeden oluşan bir dizi
verilebilir. Yatay bir kalıp, yanında iki adet aynı ancak dikey bir kalıpla birleşebilir.

Kompozit Kalıplar: Birleşmesi için ekstra işlemler gereken kalıpları temsil eder.
Örneğin iki farklı arazi yapısını belli bir noktada köprü ile bağlamak gibi bir örnek
verilebilir.

Ayrıca bu çalışmada otomatik ve prosedürel olarak geliştirilen seviyelerdeki yolların
nasıl ayrılabileceği ve birbirine bağlanabileceğinden de hücre yapısı ile
bahsedilmiştir. Doğrusal olmayan seviye tasarımının yapı taşları olan hücrelerin alt
hücreleri aslında doğrusal kalıplardan yapılmıştır. Bir hücre bir bazı diğer kalıpların
kapsüllemesidir.

Bu seviyede, özellikleri belirli bir modeller göz ardı edilir çünkü sadece oyuncunun
desenin bir ucundan diğerine geçebilir halde olması önemlidir. diğeri. Bir hücre
yapısının ucu diğer hücrelere nasıl bağlanabileceğini açıklar. Şekilde gösterilen dal
hücre yapısı, oyunculara iki yol seçeneği sunarak farklı yollar sunmanın en temel
yolu olmuştur.

Şekil 1.3 Prosedürel seviye oluşturma hücre örneği


## 2. YÖNTEM

**1.1 Adaptif Yapay Zeka**

Oyunda yapay zeka rakip bilgisayarın kullanıcıya karşı tehdit oluşturması için
düşman birimleri oluşturulmuştur. Bu düşman birimleri bir hareket hızı ve bir yaşam
puanı değerine sahiptir. Bu değer sıfırlandığında düşman birimin yok olması
gerekmektedir. Düşman birimleri yaşam puanlarını mermi isabet etmesi durumunda
kaybetmesi ve taretler tarafından yavaşlatılabilmesi için losehp() ve losespeed()
metotlarına sahip şekilde geliştirilmiştir. Düşmanlar EnemySpawner adındaki bileşen
sayesinde belirli zaman aralığında tekrarlı şekilde oluşturulmaktadır.

Oyunun sahip olduğu çoklu yolları kullanarak bu adaptif yapay zeka kullanılmak
istenmiştir. Buna örnek olarak yapay zeka ilerlediği bir yol seçer ancak seçtiği yolda
başarısız olduğu durumda yapay zeka daha uygun bir yol seçerek düşman birimleri o
yoldan ilerletmeye başlar. Bu şekilde kullanıcı tek bir yola yatırım yaparak bütün
birimlerini aynı yola koyamaz ve kullanıcıya sürekli farklı stratejiler düşündürmeye
iterek oyunu daha iyi bir tecrübe haline gelmesi sağlanmıştır.

Örnek vermek gerekirse aşağıdaki şekilde A yolundan ilerleyen düşman birimleri iyi
sonuç alamadığında A yolundan vazgeçerek B yolundan devam edecektir.

```
Şekil 2.1 Adatif yapay zekanın yol kararı örneği
```
Düşman birimler kullanıcının merkezine ulaşmak için birçok yola sahip haritadaki
bir yolu seçip ilerlemektedir. Düşman biriminin seçtiği yol boyunca kullanıcı bunu
engellemek için belli önlemler alacaktır. Kullanıcıya daha farklı ve zor bir deneyim
sunmak için rakip yapay zekanın kullanıcının stratejilerine karşı cevap verebilme
imkanı yaratmak için düşman yapay zekanın adaptif bir yapay zeka haline getirilmesi
gerekiyordu.


Bu konuda örneğin bir yoldan ilerlemeye başlayan rakip birimleri eğer aynı yoldan
gitmeye devam ederlerse kullanıcının kolay ve aynı stratejiyi tekrarlayarak herhangi
bir zorluk yaşamadan kazanması kesin hale gelir. Eğer bu yaşanırsa oyun tek düze
hale gelir ve kullanıcı açısından oyundan kötü bir deneyim yaratacağı düşünülmüştür.
Bu yüzden oyundaki yapay zekanın kullanıcının hareketlerine adapte olup kullanıcıyı
farklı stratejiler kullanmaya yönlendirilebilen bir adaptif yapay zeka tasarlanması
planlanmıştır.

**1.2 Unity Engine**

Bir komut dosyası etkinleştirildiğinde, Update yöntemlerinden herhangi biri ilk kez
çağrılmadan hemen önce çerçevede Start çağrılır [7]. Unity Engine, oyun geliştirme
motorunuz olarak onu seçmeniz için yayınlandığından beri birçok nedene sahip
güçlü bir araç olmuştur. Unity Engine'in öne çıktığı birçok temel faktör olmuştur.
Bunları aşağıda sıralanmıştır.

Hızlı Prototipleme: Unity, hızlı prototipleme için idealdir. Hızlı bir şekilde oyun
fikirlerini hayata geçirmek ve hızla test etmek için birçok hazır bileşen ve kaynak
bulunur. Ayrıca, oyunu canlı olarak önizleyebilir ve anında geri bildirim alabilirsiniz.

Kullanım Kolaylığı: Unity, kullanıcı dostu bir kullanıcı arayüzüne sahiptir ve yeni
başlayanlar için daha kolay öğrenilebilir bir araçtır. Görsel betikleme sistemi olan
Playmaker gibi eklentilerle birlikte, programlama becerisine sahip olmayan veya
sınırlı olan geliştiriciler bile oyun mekaniklerini oluşturabilir. Bunun yanında Unity
birçok yardımcı ek alete sahiptir. Bunun yanında internette Unity en çok yardımcı
videoya ve yazılı içeriğe sahip oyun motoru olarak öne çıkmaktadır.

Büyük Topluluk ve Ekosistem: Unity, geniş ve aktif bir kullanıcı topluluğuna sahip
olmuştır. Kurulduğundan beri forumlar, tartışma forumları ve çevrimiçi kaynaklar
bilgi paylaşımını ve işbirliğini kolaylaştırmıştır. Bu, sorunlarınız için çözümler ve
ipuçları bulmak için harika bir kaynak haline gelmiştir. Buna Unity Asset Store gibi
ekosistemler dahil edilebilir. Bu sayede geliştirme sürecinizi hızlandırmak için
önceden oluşturulmuş varlıkları, eklentileri ve araçları indirmenize ve kullanmanıza
olanak tanır ve geliştiricilere büyük rahatlık sağlaması amaçlanmıştır.

C# programlama dili: Unity içerisinde C# programlama dilini kullanarak oyunlar
geliştirmenizi sağlar. C#, güçlü ve öğrenmesi kolay popüler bir dildir. Bu sayede
Unity bir çok çeşitli programlama becerilerine sahip geliştiriciler için erişilebilir hale
getirilmiştir. Ek olarak, C#'ın kapsamlı topluluğu ve dokümantasyon kaynakları
sorunlarınızı çözmenize yardımcı olabilir.

Gerçek zamanlı önizleme: Unity'nin gerçek zamanlı önizleme özelliği, geliştirme
sırasında oyununuzun nasıl görüneceğini anında görmenizi sağlamıştır. Bu,
değişiklikleri anında keşfetme ve oyununuzun görsel ve davranışsal yönlerinde hızlı
ayarlamalar yapma açısından büyük bir avantajdır. Bu, geliştirme sürecini hızlandırır
ve daha verimli hale getirir. Unity Engine'in bu avantajları, oyun geliştiricilerin hızlı,
verimli, platformlar arası oyunlar oluşturmasını sağlar. Hem bağımsız geliştiriciler
hem de büyük stüdyolar arasında popüler bir seçim haline gelmesinin ana
nedenlerinden biri budur.


Çoklu platform desteği: Unity teknolojisi sayesinde oyununuzu farklı platformlara
taşımayı kolaylaştırmıştır. Windows, Mac, Linux, iOS, Android, PlayStation, Xbox
ve hatta sanal gerçeklik (VR) ve artırılmış gerçeklik (AR) gibi birçok platformu
desteklemektedir.

Bu da oyunu çok geniş bir kitleye tanıtmamızı sağlayacak. Zengin araçlar ve
kaynaklar: Geliştirme sürecinizi kolaylaştırmak için çeşitli kullanımı kolay araçlar ve
kaynaklar sağlar. Örneğin, oyun nesnelerini sürükleyip bırakmanıza izin veren görsel
bir sahne düzenleyiciye sahiptir. Ayrıca animasyon oluşturma, fizik simülasyonu, ses
entegrasyonu ve yapay zeka gibi çeşitli alanlarda geliştirme için kullanıma hazır
bileşenler sağlar.

**1.3 Taret Birimleri**

Oyun için savunmayı sağlamak adına birçok birim oluşturulmuştur. Bu birimlerin en
önemlisi oyundaki kullanıcının sürükleyip belirli noktalara yerleştirebildiği taretler
olmuştur. Bu taretler rakip bilgisayarın gönderdiği düşmanları yenmesi amacıyla
oluşturulmuştur. Yani taretler oyunu kazanma stratejisinde kullanıcının ana amacı
taretleri doğru şekilde yerleştirerek kullanıcının ana merkezini korumak ve
düşmanların ana merkeze ulaşmasını engellemektir.

Taretlerin geliştirmesinde öncelikle ortak özellikleri belirlenmiştir. Değişkenler
arasında hedef düşmanı belirten bir Transform değişkeni belirlenmiştir. Bu değişken
sayesinde taret alanına giren düşman objesi bu değişkene atanır ve gerekli işlemler
bu şekilde yapılır. Daha sonra taretin ateş edebileceği alanı belirlemek için bir ‘range’
değişkeni belirlenmiştir. Bu sayede ayrıca taretlerin ateş alanı istenen şekilde
değiştirilebilir ya da oyun içinde bu alan arttırılabilir hale gelir. Taretlerin hedefe
doğru dönmesi ve rakibin yolladığı düşmanı takip etmesi için Transform türünde
‘rotatepart’ isimli değişken belirlenmiştir.

Taretin mermi ateşleme hızı yani taret objesinin önünde mermi objesinin
oluşturulmasının hızını belirlemek için ‘fireRate’ isimli bir değişken oluşturulmuştur.
Bu değişken sayesinde oluşacak merminin saniye başı oluşma hızı belirlenebilecek
hale gelmiştir. Bunun yanında ‘bulletPart’ ve ‘fireLocation’ adlı iki değişken
merminin oluşacağı lokasyonu belirlemek için kullanılmıştır. Ayrıca merminin
ateşlenmesi için gereken fonksiyon taretin Start() fonksiyonu içinde yani bileşen
oluşur oluşmaz çalışan fonksiyonun içinde InvokeRepeating() kullanarak
çağrılmıştır. InvokeRepeating metodu sayesinde mermi çağırma fonksiyonu istenen
saniye başı miktarı kadar sürekli çağırılmaktadır. Bu fonksiyon sadece ‘range’
değişkeninin belirlediği alanda düşman bulunduğunda harekete geçirilmiştir. Taretin
düşman hedefi değiştirmesi için ChangeTarget() metodu yazılmıştır. Bu metotta
InvokeRepeating ile start() metodunda çalıştırılmıştır.

Bunun yanında mermi objesi için bir komut yazılmıştır. Bu mermi objesi sayesinde
oluştuğu taretin hedef aldığı düşmanı parametre olarak alarak o hedefi takip etmesi
için hazırlanmıştır. Mermi objesi için yazılan komutta ‘damage’ isimli düşmanın
puanını azaltacağı seviyeyi belirleyen bir değişkeni, hız için ayrı bir dğeişken vardır.
Bunun yanında yine hareket ile ilgili işlemler update() metodunda yapılmaktadır.


Bu noktada taretler farklı stratejik yöntemlere açık olması için birden fazla çeşitle
geliştirilmiştir. Bunlar klasik taret, lazer taret, ve yapışkan mermi tareti olarak üçe
ayrılmıştır.

Klasik Taret: Sahip olduğu özelliklerin çoğu yukarıda belirtilen ortak özelliklerdir.
Bu taret türü belli bir alan içine giren düşmanı tekip edip, mermi nesnei oluşturur. Bu
mermi ise düşmanı takip eder ve çarpışma sonucunda düşman birimlerin puanlarını
azaltır ve eğer sıfır haline getirirse düşman objesini yok eder.

Şekil 2.2 mermi örneği

Lazer Taret: Diğer taretlerin aksine birden çok düşmana aynı anda sürekli şekilde
hasar verebilen bir taret türüdür. Bu taretin diğer taretlerden farkı hasar vermek için
mermi ateşleyip merminin çarpmasını beklemek zorunda kalmamasıdır. Hedefleri
lazere benzer türde kırmızı şeritlerle gösterilmiştir ve saniye başına sürekli hasar
almaktadır. Lazeri temsil etmesi için kırmızı bir şerit objesi çağrılmıştır. Lazer objesi
düşman hareket ettiği sürece düşmanın lokasyonuna göre rotasyonunu
değiştirmektedir. Düşman objesi yok olduğunda ya da düşman objesi alandan
çıktığında bu lazer objesi de silinecek şekilde ayarlanmıştır.


Şekil 2.3 Taret Örneği

Yavaşlatan Taret: Diğer taretlerin aksine bu taret hasar veren mermi
ateşlememektedir. Bu mermi aslında klasik taret ile aynı mantıkta çalışmaktadır.
Ancak parametre olarak aldığı mermi hasar veren klasik değil. Düşmanın hız
değişkenini düşüren bir mermi ateşlemektedir. Bu sayede stratejik olarak farklı bir
seçim seçeneği de oluşturulmuştur.

Şekil 2.4 Yavaşlatan mermi örneği


**1.4 Düşman Birimleri**

Oyun içinde çeşitliliği sağlamak için ve oyuncunun oyunu oynarken farklı stratejiler
kurmasını sağlamak amacıyla oyuna birbirinden farklı 3 çeşit düşman çeşidi
eklenmiştir. Bu düşman çeşitlerinin oyuncunun da farkına varması için görsel
modelleri birbirinden farklıdır. Düşmanların boyutları, hızları, hasarları ve canları
birbirlerinden farklıdır. Düşmanların hasarları,hızları ve canlarının birbirlerinden
farklı olması ve rastgele bir şekilde doğmaları oyuncuya stratejik anlamda
yerleştireceği taret birimleri açısından farklı oynama yolları oluşturur

Düşmanlar 3 çeşit olarak tasarlanmıştır:

1. çeşit normal hızlı ve normal hasarlı düşmandır.

```
Şekil 2.5 Hızlı düşman örneği
```
2. çeşit hızlı ve çevik hareket eder ancak vuruş hasarı düşüktür. Bu birimin 10 canı
vardır ancak hızı 3.5tir. Bu sayede bir kuleye hızlıca ulaşıp hasar vurmaya
başlayabilir.

```
Şekil 2.6 Hızlı düşman örneği
```

3. çeşit yavaş hareket edip çok hasar vuran türdür. Bu türün canı 65 fakat yürüme hızı
1’dir. Kalelere ulaşması zor fakat ulaştığında yüksek hasar verebilmektedirler.

```
Şekil 2.7 Yavaş ve güçlü düşman örneği
```
**1.5 Rastgele Harita Oluşturma**

Yaptığımız oyunun sürekliliğini ve tekrar oynanabilirliğini aynı zamanda da zorluk
derecelerinin yapılandırılmasında rol oynayan unsur rastgele harita oluşturma
kısmıdır. Rastgele harita oluşturarak oyuncunun her seferinde aynı ya da belirli bir
miktarda önceden hazırlanmış haritalarda oynaması yerine her oyunu başlattığında
algoritma tarafından hazırlanan haritada oynaması ve çeşitlilik kazanmasıdır.

```
Şekil 2.8 Spawn metodu
```

Oyunumuz gridlerden yani karelerden oluşturulmaktadır, harita oluştuktan sonra
hazırladığımız 3D modeller bu karelerin üzerine giydirilmektedir. Oyunun
başlangıcında ortaya bir adet kare koyulur bunun yeri sabittir ve her oyun tekrarında
bütün haritanın başlangıcı bu noktadan çıkar.
Oyunu başlatan karemizin ortasında kare şeklinde bir mesh bulunur, oyunu başlatan
karemizin etrafında ise her kenarda bir adet olmak üzere 4 adet “SpawnPoint” adı
verdiğimiz bulunduğu konumda eğer şartlar uygun ise yeni kare oluşturacak
görünmez bloklar vardır. Spawn() fonksiyonumuzda bu karelerin yönlerine göre daha
önce listeledigimiz kare listesinden uygun olanı seçilip oyun dünyamıza yerleştirilir.

Kare çeşitliliğini sağlamak içinse karelerimizi “forward”,”left”,”right” ve bunların
kendi içindeki kombinasyonlu hallerine uygun olarak dosya yani prefab olarak
karelerimizi oluşturuyoruz. Bu karelerin farklılığı örneğin ilk yerleştirdiğimiz kare 4
kenarında da yeni kare oluştururken diğer hazırladığımız kareler sadece tek kenarda
ya da iki kenarda oluşturabiliyor bu sayede haritanın yönü ve çeşitliliği her oynayışta
tekrar değişiyor eğer iki kare de aynı yerde yeni bir kare oluşturmak isterse önceden
yerleştirdiğimiz görünmez blokların birbirine değip değmediğini kontrol ediyoruz
eğer değiyor ise yani iki tane kare aynı yerde yeni bir kare oluşturmak istiyor ise
orada hiçbir kare oluşmaz.

Unity Editör’ün içinde ayarlanabilir veya ana menüde zorluğu seçerek
ayarlayabildiğimiz rastgele harita jenerasyonunu etkileyen bir etmen var.
Yerleştirilebilecek maksimum kare sayısı, yerleştirilebilecek maksimum kare sayısı
ne kadar az ise oyun o kadar zorlaşıyor çünkü 3 adet savunma birimimiz son
yerleştirilen 3 kareye koyulur. Harita ne kadar büyük ve uzun olursa bu 3 savunma
karemiz oyunun başlangıç noktasından daha uzakta oluyor ve düşmanların oyuncuya
ulaşması daha uzun sürüyor bu da oynanış kısmında oyuncuya kolaylık sağlıyor.

**1.5 NavMesh ve Düşman Yapay Zekası**

NavMesh sisteminin çalışma mantığı sahnedeki statik olan engeller göz önüne
alınarak yapay zekanın gidebileceği alan hesaplanır ve bir rota bu alan üzerinden
hesaplanır. Bunun için yürünebilecek yerler sabit ve statik olarak işaretlenmesi
gerekir. Gerekli yerler statik olarak işaretlendikten sonra haritada fırınlama yani Bake
işlemi yapıp yürünebilecek yerlerin yapay zeka için render alınır.

NavMesh objelerin yapay zeka yüzeyini hesaplarken mesh ya da collider seçeneği
sunuyor, projede görünmez colliderlar olduğu için collider seçeneği yerine mesh
seçeneği kullanılıyor. Mesh ile render alındığında ise objenin modeline vertex yani
modellemede kullanılan noktaların ve yüzeylerin pozisyonlarına bakılır. Projede
kareleri tasarlarken görsel açıdan kullanmak için düz olmayan zeminler veya
dekorasyon olarak karelerin üstünde kullanılan eşyalar olduğu için direkt olarak
mesh bake edilmiyor. Bu yüzden dekorasyonları ve düz olmayan zemin oyun başında
kapalı tutulur. Oyun başında sadece yürünebilecek alanı temsil eden beyaz kareler
oluşturulur.


Bütün haritanın oluşturulması bittiği zaman yapay zeka yani NavMesh zeminin
renderını alır bu sayede aslında zemin düz olmasa bile düzmüş illüzyonu yaratılır. Bu
işlemden sonra ise yapay zeka renderı için kullanılan beyaz küpleri kaldırılır ve
yerine ilk başta kapalı olan dekorasyonlar ve düz olmayan zemin koyulur.

Şekil 2.9 Navmesh örneği

Düşman yapay zekasında ise SetDestination() methodu ile verdiğimiz 3 boyutlu
vektöre düşmanımızı hareket ettiriyoruz. Düşmanlarımızın birbirinden farklı genişlik
ve uzunlukları olabiliyor bunlar yine yolda nasıl hareket ettiklerini etkiliyor. 3 farklı
oyuncu kalesi olduğundan dolayı düşman oyuna başladığında hangi kareye gitmesi
gerektiğini seçmesi gerekiyor. Bu seçimi yaparken birden fazla unsur bu seçimi
etkiliyor. Düşman kendisinden önce oluşturulmuş ölmüş veya ölmemiş diğer
düşmanların verisini kullanarak daha isabetli bir seçim yapabiliyor. Düşman seçimini
yaparken kalenin kendisine olan uzaklığına, kaledeki mevcut trafik miktarına yani
anlık olarak o kaleye giden kaç düşman olduğuna ve daha önce o kaleye giderken
veya o kaleye ulaşıp da ölen düşman sayısını göz önünde bulundurarak seçim yapılır.
Float olarak cost değeri oluşturulur ve bu cost değeri her kale için hesaplanır.
Bulunan en küçük cost değerinin olduğu kale düşmanın kilitlenmiş hedefi olur.
Kilitlenmiş hedefin yok edilmesi durumunda ise düşman kilitlenmiş hedefin null
döndürüp döndürmediğini kontrol eder ve kilitlenmiş hedef eğer null olursa
tekrardan Think fonksiyonu ile kendine yeni hedef seçer.

Haritaya yerleştirilen taretler düşmanın kilitlenmiş hedefini bozabilir çünkü
düşmanların taretlere saldırması gerekmektedir aksi taktirde düşmanların doğma
noktasına yakın bir yere koyulan taretin veya taretlerin daha düşmanlar yeni
doğmuşken onlara büyük hasar vurma imkanı vardır, bu yüzden düşman her 1
saniyede bir 6 birim etrafında bir taret olup olmadığını kontrol eder eğer taret var ise
herhangi bir kaleye kilitlenmiş olsa bile öncelik olarak o tarete kilitlenmektedir.
Kalelerde olduğu gibi yine aynı şekilde taretler yok edildiğinde tekrar Think
fonksiyonu ile yeni hedef seçilir.


Düşmanlar öldüğünde kilitlenmiş oldukları birim eğer kale ise o kalenin
killCount’unu yani o kale yolunda ölmüş olan düşman sayısını arttırır. Yine aynı
şekilde düşman bir kaleye kilitlendiğinde anlık olarak o kalenin trafiğindeki düşman
sayısı bir artar.

**1.6 Yetenek Sistemi**

Oyunda 2 adet yetenek bulunmaktadır. Düşmanları belirli bir süreliğine dondurma
yeteneği ve yerleştirdiğimiz taretlerin atış sıklığını belirli bir süreliğine arttırma
yeteneğidir. Bu yeteneklerin belirli bir tekrar kullanıma girme süresi vardır. Bu
yetenekler oyun içinde zamanla veya düşman öldürerek kazandığımız altınlar ile
kullanılır.Dondurma yeteneği, dondurma tuşuna basıldığı zaman yeterli altın olup
olmadığını ve yeteneğin şu an kullanıma açık olup olmadığını sorgular eğer bu
sorguları geçer ise şu an oyundaki mevcut yaşayan bütün düşmanları bir dizide toplar
ve Enemy scriptlerine erişip hızlarını 0’a eşitler ardından Invoke fonksiyonu ile 3
saniye sonra bu hızlarını tekrar normal hızlarına eşitler.

Taret yeteneği, taret geliştirme tuşuna basıldığı zaman yeterli altın olup olmadığını ve
yeteneğin şu an kullanıma açık olup olmadığını sorgular eğer bu sorguları geçer ise
şu an oyundaki mevcut taretleri bir dizide toplar ve Turret scriptlerine erişip fireRate
floatını belirli bir süreliğine 3’e eşitler ardından Invoke fonksiyonu ile 3 saniye sonra
bu hızlarını tekrar normal hızlarına eşitler.

**1.7 Altın Sistemi**

Oyunda taretleri ve yetenekleri istediğimiz zaman kullanmak oyuncuya büyük bir
avantaj sağlayacağından bunları sınırlamak amacıyla bir altın yani para sistemi
eklenmiştir. Oyun başladığı andan itibaren zamana bağlı olarak altın kazanılmaktadır
ve bu UI’da oyuncuya sunulmaktadır. Altın aynı şekilde düşmanları öldürdükçe de
kazanılabilir. Enemy scriptindeki Die yani ölme fonksiyonunda oyuncunun altını
arttırılmaktadır. Taret veya yetenek kullanılaya çalışıldığında ilk önce mevcut altın
taret veya yetenek scriptinin içindeki cost miktarından fazla veya eşit mi diye kontrol
edilir. Eğer fazla veya eşitse ilk önce altın azaltılır ardından taret yerleşimi veya
yetenek uygulaması yapılır.

**1.8 Sahne Sistemi**

Oyun performans açısından iki sahneden oluşturulmuştur. Oyun sahnesi ve ana menü
sahnesi. Ana menüdeyken arkaplanda bir oyun yükü çalışmaması için bu iki olay
birbirinden ayrılmıştır. Ana menüdeki play buttonuna basıldığında SceneManager ile
bir sonraki indexteki sahne yani oyun sahnesi yüklenir.

**1.8 Düşman Doğma Sistemi**

Düşmanların doğduğu nokta haritanın ilk oluşturulmaya başlandığı noktadır.
Düşmanları EnemySpawner classında SpawnEnemies fonksiyonunda oluşturulur.
SpawnEnemies fonksiyonunu oyun başladıktan 5 saniye sonra ilk kez çalıştırılır
ardından 3 saniye boşluklarla tekrar ederek çalıştırmaya devam eder.


SpawnEnemies fonksiyonunda float random değerimize rastgele bir değer atanır. Bu
değere göre switch case yaparak oluşacak düşmanımızın objesi seçilir. Oyunda sabit
bir düşman olmadığından dolayı random değer atayarak rastgele düşman oluşması
sağlanır. Ardından bu düşman listesini başka scriptlerde kullanmak için
oluşturulduktan sonra listeye eklenir.

Şekil 2.10 Düşman oluşturma sistemi örneği

**1.8 Hasar verme, Hasar Alma Sistemi**
Hasar alma ve hasar sistemi OnTriggerEnter fonksiyonuna dayanır. Oyunda
modellerin colliderları vardır bu colliderlar fizik hesaplamaları ya da görsel
çakışmayı belirlemek için kullanılabilir. Eğer bu colliderlarda IsTrigger etike açık ise
birbirine çarpmaz ancak OnTriggerEnter fonksiyonuna çarpan objenin bilgileri gelir.
Bu yöntemi mermilerde ve oyuncu kalelerinde kullandık. Örneğin oyuncu kalesinin
görünmez olan bir karesi var ve IsTrigger değeri açık yani içine giren,çıkan veya
içinde duran objeleri bize döndürebilir. Ancak performans açısından her obje yerine
sadece düşman olan objeleri seçmeyi amaçlar. Bunun için Unity’nin tag sistemi
vardır. Objelere isminin yanı sıra etiket verilir. Oyunumuzda düşman birimlerine
Enemy etiketi verilmiştir. Bu sayede kale OnTriggerEnter fonksiyonuna giren
objenin ilk önce Enemy etiketine sahip olup olmadığını kontrol eder, eğer sahipse
Enemy’nin scripti içerisinden hasar değerini alır ve bunu her frame yerine saniye
başı olarak kalenin canına yansıtır. Bütün birimlerde hasar alma fonksiyonunda can
azaltılırken canın 0’dan az bir değere ulaşıp ulaşmadığı kontrol edilir. Eğer ulaştı ise
obje yok edilir ve null atanır.


Şekil 2.11 Hasar verme örneği

**1.8 Can Barı Sistemi**

Oyunumuzda can barları için bir Image kullanılır. Bu resimler karakterlerin veya
binaların içerisinde World Space dediğimiz alandadır. World Space 3D bir oyun
zeminini temsil ederken UI için kullanılan Screen Space 2D yani bilgisayarımızın
monitörünü temsil eder. Can barının objelerle tam olarak örtüşmesini sağlamak için
bu resmi Screen Space yerine World Space kısmına alındı. Farklı objeler için farklı
renk can barları hazırlandı.

Can barları hasar alındıktan sonra kalan can miktarını 0 ile 1 arasında oranlar ve bu
oran can barındaki resmin Fill Amount’u olur yani soldan sağa doğru resmin
kırpılma oranı bu oran 1 iken yani birimin canı full iken resimin tam hali
gözükmektedir. Can azalıp bu oran düşmeye başladığında ise resim de kırpılmaya
başlamıştır.


## 3. SONUÇLAR VE ÖNERİLER

Bu çalışma sonucunda projeyi geliştirirken ses komutları ve yön bulma algoritmaları
ile geliştirilen oyun yazılımlarında geliştirmeye yardımcı olacak birçok şey
tanıtılarak, geçmişte benzer yapıda geliştirilen örneklere de yer verilmiş ve detaylıca
bahsedilmiştir. Ses kontrollerini proje içinde kullanırken yaşayabileceğimiz bir sorun
olan ses kontrollerinin kesin bir obje hedefi olmayışının çözümü tespit edilmiştir.
Artık ses kontrolleriyle yapılan uygulamalarda, problem çözme ve düşünme
gerektirmediği zaman %30 civarında akıcı hale geldiği görülmüştür bu yüzden
uygulamayı geliştirirken kullanıcının akıcı bir deneyim elde etmesi için oyunun
basitliği göz önünde olması gereken konulardan biri olduğuna karar verilmiştir.

Ayrıca ses kontrollerinde çoğunlukla kullanıcıların kısa ve özetleyici komutlar tercih
ettiği bu yüzden yapılacak oyun sırasında ses komutlarının olabildiğince kısa olması
planlanmıştır. Bunun yanında çalışmalar içinde bahsedilen ses komutlarıyla yapılan
eski projelerin örnek temsil edeceği düşünülmüştür.

Yön bulma algoritmaları ve yön bulma algoritmalarının nasıl çalıştığından
bahsedilmiştir. Farklı yön bulma algoritmaları farklı noktalarda farklı durumlarda
daha iyi seçenekler olduğundan hepsinden detaylıca bahsedilmiş ve geçerli proje için
hangi algoritmanın neden seçildiğinin üzerinde durulmuştur. Oyunlarda yol bulmayı
hareket sisteminin çekirdeği olduğu birinci elden deneyimlenmiştir.

Yön bulma algoritmasında farklı algoritmalar denenmiş en optimize ve en hatasız
sonucun birbirine eş modellerin örneğin karelerin birbirini oluşturması ve
şekillendirilmesiyle olduğuna karar verilmiştir. Daha önce denediğimiz önceden
hazırlanmış 3-5 karelik şekillerin birleştirilmesi olumlu sonuç sağlamamakla beraber
oyunda istediğimiz rastgele oluşum değerini de düşürmüştür, bu yüzden hem rastgele
oluşum ve performans adına grid sistemi yani kare sistemi tercih edilmiştir.

Yön bulma algoritmalarının yazılıma geçirme aşamasında bilgisayar kaynaklarını
fazla tüketmemesi içinde araştırma yapılmıştır. İşlemci tüketimi gerçekleştirmemek
için ya da işlemci tüketimini azaltmak için yapay zeka yol bulucu hareketi
yönlendirmek için genelde önceden hesaplanmış yol bilgilerini de kullanır. Örneğin
sadece yürünebilir yerlerin koordinatını kullanıp eğer çıkan rotada yürünemiyorsa o
yolları hatırlayıp bir daha kullanmaya çalışmaması gibi örneklendirilebilir.

Sonuç olarak seviyelerin prosedürel otomatik olarak oluşturulan ve yapay zekanın
adaptif hale getirildiği bir kule savunması oyunu geliştirilmiştir. Oyun içindeki
objelerin modellemesi yapılmıştır. Oyunun genel tasarımı planlanıp uygulamaya
geçirilmiştir. Prosedürel olarak geliştirilen seviyelerde adaptif yapay zeka
kullanımının zorlukları tecrübe edilmiştir.


